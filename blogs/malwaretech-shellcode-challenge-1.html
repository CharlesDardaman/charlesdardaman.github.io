<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MalwareTech Shellcode Challenge #1</title>
    <meta name="description" content="Walkthrough of MalwareTech's beginner shellcode challenge, reverse engineering the decoder and recovering the flag." />
    <link rel="stylesheet" href="../assets/css/blog.css" />
  </head>
  <body>
    <header class="masthead">
      <div class="masthead__inner">
        <div class="brand">
          <a class="brand__link" href="../index.html">Charles Dardaman</a>
          <p class="brand__tagline">Security engineering, incident response, research.</p>
        </div>
        <nav class="site-nav" aria-label="Primary">
          <ul>
            <li><a href="../index.html#about">About</a></li>
            <li><a href="../index.html#writing">Writing</a></li>
            <li><a href="../index.html#connect">Connect</a></li>
          </ul>
        </nav>
      </div>
    </header>

    <header class="post-header">
      <h1>MalwareTech Shellcode Challenge #1</h1>
      <p><time datetime="2018-05-25">May 25, 2018</time></p>
    </header>

    <main>
      <article>
        <p>
          Today, MalwareTech posted a beginner's reverse engineering challenge on Twitter, and I thought it would be fun to go through it and write up how to do it with IDA and Python.
        </p>
        <blockquote class="twitter-tweet">
          <p lang="en" dir="ltr">Testing out a beginner challenge designed to introduce people to use of shellcode in malware, let me know what you think!<a href="https://t.co/oCVIFRSlBF">https://t.co/oCVIFRSlBF</a></p>&mdash; MalwareTech (@MalwareTechBlog) <a href="https://twitter.com/MalwareTechBlog/status/999399940731240449?ref_src=twsrc%5Etfw">May 23, 2018</a>
        </blockquote>
        <p>
          The ZIP file contained two files, <code>README.txt</code> and <code>shellcode1.exe</code> (which is the challenge file).
        </p>
        <p>
          <code>README.txt</code> contains the basic rules of the challenge, stating that it's meant to be done statically with IDA and not with a debugger. It also tells us that running the binary will output an MD5 of the flag.
        </p>
        <p>
          To confirm this, I ran the executable to see what happens. (Please keep in mind that you should never execute code that you don't trust on your system. I ran the file inside of a VM.)
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-1/1.png" alt="Message box displaying the MD5 hash of the flag" />
        </figure>
        <p>
          As we can see, it opens up a message box titled “We've been compromised!” and includes the hash of the flag, just as the README said it would.
        </p>
        <p>
          I opened up IDA Pro to take a better look at the binary. As soon as it loads, the function window shows almost all functions are related to MD5, which makes sense given the size of the binary and our knowledge that it utilizes MD5 to hash the flag.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-1/2.png" alt="IDA Pro function list revealing mostly MD5-related functions" />
        </figure>
        <p>
          Next, I inspected the imports to understand which Windows libraries are being used. The binary can call a message box, allocate space in memory, allocate on the heap, and get the length of a string.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-1/3.png" alt="IDA Pro view showing imported functions including MessageBoxA" />
        </figure>
        <p>
          Returning to the start function, the assembly shows a <code>MessageBoxA</code> call at the bottom. The offset <code>a2bBBb</code> is used in <code>digestString</code> before it is passed to <code>MessageBoxA</code>. This tells me that <code>a2bBBb</code> is the flag I'm looking for. To track it easily, I renamed the offset to <em>flag</em> and continued through the code.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-1/4.png" alt="IDA Pro screenshot highlighting the flag string being hashed" />
        </figure>
        <p>
          Knowing where the flag is located, I moved back to the top of the function and saw that it allocates space on the heap, adds a pointer to the flag into that space, and then adds the length of the flag onto the heap as well.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-1/5.png" alt="Assembly allocating heap memory and storing the flag pointer" />
        </figure>
        <p>
          The next section allocates a 13-byte region of memory and copies whatever is at <code>unk_404068</code> into that region before calling it as code.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-1/6.png" alt="Assembly copying decoder shellcode into executable memory" />
        </figure>
        <p>
          Jumping to the <code>unk</code> location, IDA initially shows raw bytes. After pressing <kbd>C</kbd> to convert it, IDA renders the following readable assembly. This code takes the location of the flag (stored in the heap structure) and rotates each byte left by five bits.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-1/5.png" alt="Decoded shellcode performing ROL operations on the flag bytes" />
        </figure>
        <p>
          This shellcode acts as a decoder, transforming the stored flag before hashing. To replicate the decoding, I tweaked a Python rotate script I found to match the behavior.
        </p>
        <pre><code class="language-python">from __future__ import print_function

# max_bits &gt; 0 == width of the value in bits (e.g., int_16 -&gt; 16)

# Rotate left: 0b1001 --&gt; 0b0011
rol = lambda val, r_bits, max_bits: (
    (val &lt;&lt; (r_bits % max_bits)) &amp; (2**max_bits - 1)
) | (
    (val &amp; (2**max_bits - 1)) &gt;&gt; (max_bits - (r_bits % max_bits))
)

# Rotate right: 0b1001 --&gt; 0b1100
ror = lambda val, r_bits, max_bits: (
    (val &amp; (2**max_bits - 1)) &gt;&gt; (r_bits % max_bits)
) | (
    (val &lt;&lt; (max_bits - (r_bits % max_bits))) &amp; (2**max_bits - 1)
)

max_bits = 8  # For fun, try 2, 17 or other arbitrary (positive!) values

shellcode = ["Insert encoded flag hex here"]

final = ""
for value_hex in shellcode:
    value = int("0x" + value_hex, 16)
    new_value = rol(value, 5, max_bits)
    print("0x%08x &lt;&lt; 0x05 --&gt; 0x%08x" % (value, new_value))
    final += chr(new_value)

print(final)
</code></pre>
        <p>
          With this script ready, I copied the bytes referenced by the flag location and pasted them into the <code>shellcode</code> list. Running the script reveals the final flag.
        </p>
      </article>
      <div class="footer">
        <a href="../index.html">← Back to homepage</a>
      </div>
    </main>

    <footer class="site-footer">
      <p>&copy; <span id="current-year"></span> Charles Dardaman</p>
    </footer>

    <script>
      const year = new Date().getFullYear();
      document.getElementById("current-year").textContent = year;
    </script>
  </body>
</html>
