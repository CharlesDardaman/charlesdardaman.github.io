<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>MalwareTech Shellcode Challenge #2</title>
    <meta name="description" content="Reverse engineering MalwareTech's second shellcode challenge by unpacking dynamic imports, file operations, and the XOR decoder." />
    <link rel="stylesheet" href="../assets/css/blog.css" />
  </head>
  <body>
    <header class="masthead">
      <div class="masthead__inner">
        <div class="brand">
          <a class="brand__link" href="../index.html">Charles Dardaman</a>
          <p class="brand__tagline">Security engineering, incident response, research.</p>
        </div>
        <nav class="site-nav" aria-label="Primary">
          <ul>
            <li><a href="../index.html#about">About</a></li>
            <li><a href="../index.html#writing">Writing</a></li>
            <li><a href="../index.html#connect">Connect</a></li>
          </ul>
        </nav>
      </div>
    </header>

    <header class="post-header">
      <h1>MalwareTech Shellcode Challenge #2</h1>
      <p><time datetime="2018-05-26">May 26, 2018</time></p>
    </header>

    <main>
      <article>
        <p>
          Yesterday, MalwareTech posted two shellcode challenges. I spent some time going through the first challenge and wrote a walkthrough of it <a href="malwaretech-shellcode-challenge-1.html">here</a>. I recommend reading it first, as some of the code is similar. This write-up focuses on the second challenge using IDA Pro and Python.
        </p>
        <blockquote class="twitter-tweet">
          <p lang="en" dir="ltr">Here is part 2 which follows on from shellcode1 (and turns up the heat a little).<a href="https://t.co/n26hPHyiaS">https://t.co/n26hPHyiaS</a></p>&mdash; MalwareTech (@MalwareTechBlog) <a href="https://twitter.com/MalwareTechBlog/status/999702024496152576?ref_src=twsrc%5Etfw">May 24, 2018</a>
        </blockquote>
        <p>
          Just like the first challenge, the ZIP archive shipped with a README and the binary. The README explains that the challenge should be solved statically—no debuggers—and that running the binary will output the MD5 hash of the flag.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-2/1.png" alt="Message box displaying the MD5 hash for challenge 2" />
        </figure>
        <p>
          Jumping into IDA, the start function looks similar to challenge one. Because I know the binary prints an MD5 hash via a message box, I scan near the bottom and see the decrypted flag ends up in <code>var_28</code> before it is displayed.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-2/2.png" alt="IDA Pro screenshot highlighting var_28 being passed to MessageBox" />
        </figure>
        <p>
          Moving back to the top, the first thing the binary does is fill <code>var_28</code> with junk data—even though we know it will eventually hold the decoded flag.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-2/3.png" alt="Assembly showing data being moved into var_28" />
        </figure>
        <p>
          Next it allocates heap space and pushes four items into the structure: <code>LoadLibrary</code>, <code>GetProcAddress</code>, <code>var_28</code>, and the integer <code>36</code>.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-2/4.png" alt="Heap structure storing API pointers and data length" />
        </figure>
        <p>
          With the heap primed, the binary allocates executable memory, copies in a shellcode blob, and jumps to it—exactly like challenge one.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-2/5.png" alt="Assembly copying shellcode into executable memory and calling it" />
        </figure>
        <p>
          Stepping into the shellcode, things get more interesting. The blob is much larger and makes up the majority of the program's behavior. After breaking it apart, it falls into three sections: dynamic imports, file operations, and the decoder.
        </p>
        <p>
          The dynamic import section lives at the top. It moves characters one by one into memory to form strings—a common trick to hide them from basic static analysis. Decoding them reveals <code>msvcrt.dll</code>, <code>kernel32.dll</code>, <code>fopen</code>, <code>fread</code>, <code>fseek</code>, <code>fclose</code>, <code>GetModuleFileNameA</code>, and the mode string <code>rb</code>. (In IDA, highlight each byte and press <kbd>R</kbd> to convert to ASCII.)
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-2/6.png" alt="Shellcode building API strings byte by byte" />
        </figure>
        <p>
          Once the strings are in place, the code moves <code>LoadLibrary</code> into <code>ebp-4</code> and <code>GetProcAddress</code> into <code>ebp-44</code>. It repeatedly calls them to resolve each API needed for later file operations.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-2/7.png" alt="Shellcode resolving API addresses dynamically" />
        </figure>
        <p>
          With imports resolved, the second section handles file operations. It grabs a handle to the current binary (<code>GetModuleFileNameA</code>), opens the file (<code>fopen</code>), seeks to offset 0x4E (decimal 78) (<code>fseek</code>), reads the next 38 bytes into a buffer (<code>fread</code>), and then closes the handle (<code>fclose</code>).
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-2/8.png" alt="Shellcode performing fopen, fseek, fread, and fclose" />
        </figure>
        <p>
          To see what lands in the buffer, I opened the binary in a hex editor, navigated to offset 78, and copied the following 38 bytes.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-2/9.png" alt="Hex editor view of the encoded flag bytes" />
        </figure>
        <p>
          Finally, the decoder loop iterates over the buffer, XORing each byte with the corresponding byte from <code>var_28</code>—the location that ultimately holds the plaintext flag.
        </p>
        <figure>
          <img src="../assets/malwaretech-shellcode-challenge-2/10.png" alt="Decoder loop XORing buffer bytes with var_28" />
        </figure>
        <p>
          At this point I know the encoded flag bytes and the XOR key. The remaining step is to recreate the loop in Python to reveal the flag.
        </p>
        <pre><code class="language-python">flag_bytes = [0x00]  # replace with encoded flag bytes
key_bytes = [0x00]   # replace with buffer bytes

result = ""
for index in range(len(flag_bytes)):
    decoded = key_bytes[index] ^ flag_bytes[index]
    result += chr(decoded)

print(result)
</code></pre>
        <p>
          After copying the bytes from <code>var_28</code> and the buffer into the script, running it prints the flag.
        </p>
      </article>
      <div class="footer">
        <a href="../index.html">← Back to homepage</a>
      </div>
    </main>

    <footer class="site-footer">
      <p>&copy; <span id="current-year"></span> Charles Dardaman</p>
    </footer>

    <script>
      const year = new Date().getFullYear();
      document.getElementById("current-year").textContent = year;
    </script>
  </body>
</html>
